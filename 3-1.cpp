#include<stdio.h>

/*
【解題思路】
線段是否重疊可以用開使和結束的位置來判斷，並有以下可能狀況：
1. 線段1開頭<=線段2開頭，且線段1結尾>=線段2結尾 => 線段1包含線段2
2. 線段1開頭<線段2開頭，且線段1結尾<線段2結尾 => 線段1部分重疊線段2且線段1在前
3. 線段1結尾<線段2開頭 => 線段1不重疊線段2且線段1在前

為了方便處理，可以先藉由線段開頭進行排列，接著只需要判斷開頭在前線段和在後線段關係
*/

int main()
{
    int n=0;
    int line[10000][2]={{0}};

    scanf(" %d",&n);

    //獲得線段並由開始端點座標進行排序
    for(int i=0;i<n;++i)
    {
        scanf(" %d %d",&line[i][0],&line[i][1]);

        for(int j=0;j<i;++j)
        {
            //如果找到開頭比取得線段大則插入在其前
            //若沒發現則放到所有線段之後
            if(line[i][0]<line[j][0])
            {
                int temp[2]={line[i][0],line[i][1]};
                //將線段往後挪移
                for(int k=i;k>j;--k)
                {
                    line[k][0]=line[k-1][0];
                    line[k][1]=line[k-1][1];
                }

                //將線段插入到位
                line[j][0]=temp[0];
                line[j][1]=temp[1];
                break;
            }
        }
    }

    //判斷線段狀況
    int start=line[0][0],end=line[0][1];//使用第一條線段和後續線段判斷
    int length=0;//總長度
    for(int i=1;i<n;++i)
    {
        //由於進行過排序，狀況1不會影響長度(必然是線段1包含線段2)
        //若為狀況2則可視為延長現有線段（或說是線段結合）
        if(line[i][0]<=end)
        {
            //將線段的結束端點座標延後
            if(line[i][1]>end)end=line[i][1];
        }
        else//狀況3
        {
            //由於線段中斷，因此可先將前線段長度加總到總長度
            length+=(end-start);
            //接著將新線段的開頭和結束來開始計算
            start=line[i][0];
            end=line[i][1];
        }
    }
    //最後將線段加總到總長度
    length+=(end-start);

    printf("%d",length);

    return 0;
}
